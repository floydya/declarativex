{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to DeclarativeX \ud83d\ude80","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Hey there! Welcome to the official documentation of DeclarativeX. If you're tired of writing boilerplate code for HTTP clients and want a more declarative approach, you're in the right place. DeclarativeX is designed to make your life easier, letting you focus on what really matters\u2014your application logic.</p>"},{"location":"#installation","title":"Installation","text":"<p>Getting started with DeclarativeX is a breeze. Just run the following command:</p> <pre><code>pip install declarativex\n</code></pre> <p>And boom! You're good to go.</p>"},{"location":"#available-extras","title":"Available extras","text":"<p>DeclarativeX comes with a few extras that you can install separately. Here's a list of available extras:</p> <ul> <li><code>http2</code> - HTTP/2 support</li> <li><code>graphql</code> - GraphQL support</li> <li><code>brotli</code> - Brotli compression support</li> </ul> <p>To install an extra, just add it to the end of the command:</p> AllOnly one <pre><code>pip install declarativex[http2,graphql,brotli]\n</code></pre> <pre><code>pip install declarativex[http2]\n</code></pre>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<p>Ready to dive in? Here's a quick example to get you started:</p> SyncAsync my_client.py<pre><code>from declarativex import BaseClient, http\n\n\n@http(\"GET\", \"/users/{user_id}\", \"https://example.com\")\ndef get_user(user_id: int) -&gt; dict:\n    ...\n\n\nresponse = get_user(user_id=1)\nprint(response)\n</code></pre> my_client.py<pre><code>import asyncio\n\nfrom declarativex import BaseClient, http\n\n\n@http(\"GET\", \"/users/{user_id}\", \"https://example.com\")\nasync def get_user(user_id: int) -&gt; dict:\n    ...\n\n\nresponse = asyncio.run(get_user(user_id=1))\nprint(response)\n</code></pre> <p>You should see the following output:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"John Doe\"\n}\n</code></pre> <p>Async</p> <p>DeclarativeX supports both synchronous and asynchronous HTTP requests. Just define your function as <code>async</code> and you're good to go.</p> <p>See? No fuss, just clean and straightforward code.</p>"},{"location":"#why-declarativex","title":"Why DeclarativeX?","text":"<ul> <li>Less Boilerplate: No more repetitive code for HTTP methods.</li> <li>Type-Safe: Built with type annotations for better code quality.</li> <li>Flexible: Easily extendable to fit your specific needs.</li> </ul>"},{"location":"#whats-next","title":"What's Next?","text":"<p>Feel free to explore the documentation to get a deeper understanding of DeclarativeX. Whether you're looking to understand the core concepts, decorators, or how to set up dependencies, we've got you covered.</p> <ul> <li>BaseClient</li> <li>HTTP Declaration</li> <li>Dependencies</li> <li>Middlewares</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Love DeclarativeX and want to contribute? Awesome! Check out our Contribution Guidelines.</p>"},{"location":"compatibility/","title":"Compatibility \ud83e\udd1d","text":""},{"location":"compatibility/#introduction","title":"Introduction","text":"<p>Hey folks! So, you're wondering how DeclarativeX plays along with other libraries and Python versions, huh? Well, you're in the right place. Let's break it down.</p>"},{"location":"compatibility/#python-versions","title":"Python Versions","text":"<p>DeclarativeX is compatible with Python 3.9 and above. So, if you're still on Python 2 or Python 3.6 (why though?), it's time to make the jump.</p> <p>Python Version Support</p> <p>DeclarativeX is tested against Python <code>3.9</code>, <code>3.10</code> and <code>3.11</code>.  Future versions will be supported as they're released.</p>"},{"location":"compatibility/#pydantic-compatibility","title":"Pydantic Compatibility","text":"<p>We love Pydantic, and we know you do too. That's why DeclarativeX is designed to work seamlessly with both Pydantic v1 and v2.</p> <p>Pydantic Versions</p> <p>Whether you're on Pydantic v1 or planning to upgrade to v2, DeclarativeX has got your back.</p>"},{"location":"compatibility/#async-support","title":"Async Support","text":"<p>Asynchronous programming is the future, and DeclarativeX is ready for it.  You can use it with any async framework like FastAPI or Starlette.</p> <p>Async Support</p> <p>DeclarativeX is fully compatible with asynchronous frameworks.  Just make sure to use the async methods where applicable.</p>"},{"location":"contributing/","title":"Contributing to DeclarativeX \ud83d\udee0\ufe0f","text":""},{"location":"contributing/#hey-future-contributor","title":"Hey, Future Contributor! \ud83d\udc4b","text":"<p>First off, thanks for considering contributing to DeclarativeX! Whether it's fixing bugs, adding new features, or improving documentation, every contribution counts, and I'm stoked to have you on board.</p>"},{"location":"contributing/#ground-rules","title":"Ground Rules \ud83d\udcdc","text":"<p>Before we dive in, let's set some ground rules to ensure a smooth and enjoyable contribution process for everyone:</p> <ol> <li>Be Respectful: Let's keep the conversation friendly and professional.</li> <li>Code of Conduct: Please follow our Code of Conduct to maintain a welcoming community.</li> <li>Quality Over Quantity: We're all for contributions, but let's focus on quality rather than just ticking off    numbers.</li> </ol>"},{"location":"contributing/#getting-started","title":"Getting Started \ud83d\ude80","text":""},{"location":"contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>Start by forking the DeclarativeX repository to your GitHub account.</p>"},{"location":"contributing/#2-set-up-your-local-environment","title":"2. Set Up your local environment","text":"<p>Clone your forked repository to your local machine:</p> <pre><code>git clone https://github.com/&lt;your-username&gt;/declarativex.git\ncd declarativex\npoetry install\n</code></pre>"},{"location":"contributing/#3-create-a-branch","title":"3. Create a branch","text":"<p>Create a new branch for your feature or bugfix:</p> <pre><code>git checkout -b &lt;branch-name&gt;\n</code></pre>"},{"location":"contributing/#4-make-your-changes","title":"4. Make your changes","text":"<p>Now that you're all set up, you can start making your changes. Don't forget to commit them.</p> <pre><code>git add .\ngit commit -m \"Add my awesome feature\"\n</code></pre>"},{"location":"contributing/#5-run-tests-and-linters","title":"5. Run tests and linters","text":"<p>Before submitting your changes, make sure to run the tests and linters to ensure that everything is working as expected.</p> <pre><code>make\n</code></pre>"},{"location":"contributing/#6-submit-a-pull-request","title":"6. Submit a pull request","text":"<p>Push your changes to your fork and create a pull request.</p>"},{"location":"contributing/#review-process","title":"Review Process \ud83d\udcdd","text":"<p>All pull requests will be reviewed by the maintainers. If there are any comments or suggestions, you'll be notified through GitHub. Once everything is good to go, your pull request will be merged.</p>"},{"location":"contributing/#recognition","title":"Recognition \ud83c\udfc6","text":"<p>We're all about giving credit where credit is due. All contributors will be recognized in the Hall of Fame section of the documentation.</p>"},{"location":"contributing/#questions-or-security-issues","title":"Questions or Security Issues? \ud83e\udd14","text":"<p>If you have any questions, feel free to reach out to use through issues. We're here to help!</p> <p>Danger</p> <p>If you discover a security vulnerability, please <code>DON'T</code> create an issue.</p> <p>Instead create a topic in the Security Advisories!</p> <p>We'll take care of it ASAP.</p>"},{"location":"contributing/#thank-you","title":"Thank You! \ud83d\ude4f","text":"<p>Once again, thanks for considering contributing to DeclarativeX. We're excited to see what you'll come up with!</p>"},{"location":"license/","title":"License \ud83d\udcdc","text":""},{"location":"license/#the-mit-license-mit","title":"The MIT License (MIT)","text":"<p>Hey, thanks for checking out the legal stuff! We're using the MIT License for DeclarativeX, which is super permissive. Basically, you can do whatever you want with this code, as long as you include the original copyright and license notice in any copy of the software or substantial portion of it.</p> <pre><code>The MIT License (MIT)\n\nCopyright (c) 2023 to present Vladyslav Halatskyi and individual contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#what-does-this-mean","title":"What Does This Mean? \ud83e\udd14","text":"<ul> <li>Freedom to Use: You're free to use this software in any project, commercial or otherwise.</li> <li>Freedom to Modify: Want to add features or fix bugs? Go for it!</li> <li>Freedom to Share: You can distribute the original or your modified version as you see fit.</li> </ul>"},{"location":"license/#the-catch","title":"The Catch \ud83c\udfa3","text":"<ul> <li>Include the License: Just make sure to include the full license text in your project.</li> <li>No Warranty: The software is provided \"as is\", so we're not responsible if it accidentally sets your computer on fire.   Just kidding, but seriously, use at your own risk.</li> </ul>"},{"location":"license/#questions","title":"Questions? \ud83e\udd37\u200d\u2640\ufe0f","text":"<p>If you've got any questions about the license, feel free to reach out. We're not lawyers, but we'll do our best to help you out.</p>"},{"location":"testing/","title":"Testing DeclarativeX \ud83e\uddea","text":""},{"location":"testing/#introduction","title":"Introduction","text":"<p>Hey, Tester! So you're the kind of person who likes to make sure everything's working as it should, huh? Good on ya! Testing is crucial, and DeclarativeX is no exception. This guide will walk you through how to set up and write tests for your DeclarativeX project.</p> <p>Note</p> <p>We'll be using pytest for our examples. If you're not familiar with it, you might wanna check it out. It's pretty rad.</p>"},{"location":"testing/#setting-up-your-test-environment","title":"Setting Up your Test Environment","text":"<p>First things first, let's get your test environment up and running. You'll need to install pytest and any other dependencies you might need.</p> <pre><code>pip install pytest\n</code></pre> <p>Tip</p> <p>You can also create a requirements-test.txt file to manage your test dependencies separately. Just run pip install -r requirements-test.txt to install them all in one go.</p>"},{"location":"testing/#writing-your-first-test","title":"Writing your first test","text":"<p>Alright, let's write our first test. Create a file named test_client.py in your tests directory.</p> <pre><code>import pytest\n\nfrom myapp.services.example import ExampleClient\n\n\nclass TestExampleClient:\n\n    @pytest.fixture\n    def client(self):\n        return ExampleClient()\n\n    def test_get_user(self, client):\n        response = client.get_user(user_id=1)\n        assert response.status_code == 200\n        assert response.data == {\"id\": 1, \"name\": \"John Doe\"}\n</code></pre> <p>Warning</p> <p>Make sure you mock any external calls to prevent actual API requests during tests. E.g. you can mock them in <code>conftest.py</code> with patch context managers.</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>To run your tests, simply execute the following command:</p> <pre><code>pytest\n</code></pre> <p>Success</p> <p>If everything's set up correctly, you should see a beautiful green line of dots indicating your tests have passed. If not, back to the drawing board!</p>"},{"location":"testing/#advanced-testing","title":"Advanced Testing","text":"<p>Feeling adventurous? You can also write more advanced tests, like testing exceptions, timeouts, and so on.</p> <p>Info</p> <p>Check out the pytest documentation for more advanced features like parameterized testing, fixtures, and markers.</p>"},{"location":"api/exceptions/","title":"Exceptions - API DeclarativeX Documentation","text":""},{"location":"api/exceptions/#module-exceptionspy","title":"module <code>exceptions.py</code>","text":""},{"location":"api/exceptions/#global-variables","title":"Global Variables","text":"<ul> <li>TYPE_CHECKING</li> </ul>"},{"location":"api/exceptions/#class-annotationexception","title":"class <code>AnnotationException</code>","text":"<p>Raised when an unsupported annotation is used.</p> <p>Parameters:</p> <ul> <li><code>annotation</code> (<code>Type</code>):  The annotation that was used.</li> </ul>"},{"location":"api/exceptions/#function-__init__","title":"function <code>__init__</code>","text":"<pre><code>__init__(annotation: Type)\n</code></pre>"},{"location":"api/exceptions/#class-declarativeexception","title":"class <code>DeclarativeException</code>","text":"<p>Base class for all declarativex exceptions.</p>"},{"location":"api/exceptions/#class-dependencyvalidationerror","title":"class <code>DependencyValidationError</code>","text":"<p>Raised when a dependency cannot be validated.</p> <p>Parameters:</p> <ul> <li><code>expected_type</code> (<code>Union[Type, Sequence[Type]]</code>):  The dependency that failed validation.</li> <li><code>received_type</code> (<code>Type</code>):  The type that was received.</li> </ul>"},{"location":"api/exceptions/#function-__init___1","title":"function <code>__init__</code>","text":"<pre><code>__init__(expected_type: Union[Type, Sequence[Type]], received_type: Type)\n</code></pre>"},{"location":"api/exceptions/#class-httpexception","title":"class <code>HTTPException</code>","text":"<p>Raised when a request fails with HTTP status code.</p> <p>Parameters:</p> <ul> <li><code>request</code> (<code>httpx.Request</code>):  The request that failed.</li> <li><code>response</code> (<code>httpx.Response</code>):  The response that was received.</li> <li><code>raw_request</code> (<code>RawRequest</code>):  The raw request that was sent.</li> <li><code>error_mappings</code> (<code>Mapping[int, Type]</code>):  A mapping of status codes to error models.</li> </ul>"},{"location":"api/exceptions/#function-__init___2","title":"function <code>__init__</code>","text":"<pre><code>__init__(\n    request: Request,\n    response: Response,\n    raw_request: 'RawRequest',\n    error_mappings: Optional[Mapping[int, Type]] = None\n)\n</code></pre>"},{"location":"api/exceptions/#property-response","title":"property response","text":"<p>The response that was received. If a model is specified, the response will be parsed and returned as an instance of that model. :return: httpx.Response or Instance of self._model</p>"},{"location":"api/exceptions/#class-misconfiguredexception","title":"class <code>MisconfiguredException</code>","text":"<p>Raised when a client is misconfigured.</p>"},{"location":"api/exceptions/#class-timeoutexception","title":"class <code>TimeoutException</code>","text":"<p>Raised when a request times out.</p> <p>Parameters:</p> <ul> <li><code>timeout</code> (<code>Optional[float]</code>):  The timeout in seconds.</li> <li><code>request</code> (<code>httpx.Request</code>):  The request that timed out.</li> </ul>"},{"location":"api/exceptions/#function-__init___3","title":"function <code>__init__</code>","text":"<pre><code>__init__(timeout: Optional[float], request: Request)\n</code></pre>"},{"location":"api/exceptions/#class-unprocessableentityexception","title":"class <code>UnprocessableEntityException</code>","text":"<p>Raised when a request fails when parsing of the response fails.</p> <p>Parameters:</p> <ul> <li><code>response</code> (<code>httpx.Response</code>):  The response that was received.</li> </ul>"},{"location":"api/exceptions/#function-__init___4","title":"function <code>__init__</code>","text":"<pre><code>__init__(response: Response)\n</code></pre>"},{"location":"api/exceptions/#class-ratelimitexceeded","title":"class <code>RateLimitExceeded</code>","text":"<p>Raised when a request fails due to rate limiting.</p>"},{"location":"api/models/","title":"Models - API DeclarativeX Documentation","text":""},{"location":"api/models/#module-models","title":"module <code>models</code>","text":""},{"location":"api/models/#global-variables","title":"Global Variables","text":"<ul> <li>SUPPORTED_METHODS</li> </ul>"},{"location":"api/models/#class-response","title":"class <code>Response</code>","text":"<p>Wrapper around httpx.Response that provides a method to convert the response to a specific type.</p> <p>Parameters:</p> <ul> <li><code>response</code>:  The response to wrap.</li> </ul> <p>Methods:</p> <ul> <li><code>as_type</code>:  Convert the response to a specific type.</li> <li><code>as_type_for_func</code>:  Convert the response to the return type of function.</li> </ul>"},{"location":"api/models/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(response: Response) \u2192 None\n</code></pre>"},{"location":"api/models/#method-as_type","title":"method <code>as_type</code>","text":"<pre><code>as_type(type_hint: Type)\n</code></pre> <p>Convert the response to a specific type. Supports dataclasses, pydantic models, dictionaries and lists of them.</p>"},{"location":"api/models/#method-as_type_for_func","title":"method <code>as_type_for_func</code>","text":"<pre><code>as_type_for_func(func: Callable[, ~ReturnType]) \u2192 ~ReturnType\n</code></pre> <p>Convert the response to the return type of function.</p>"},{"location":"api/models/#class-clientconfiguration","title":"class <code>ClientConfiguration</code>","text":"<p>Configuration for a client. This class is used to configure the client with default values for query parameters, headers, middlewares and error mappings. The configuration can be passed to the client as a parameter or as a class attribute.</p>"},{"location":"api/models/#method-__init___1","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    base_url: Optional[str] = None,\n    auth: Optional[Auth] = None,\n    default_query_params: Dict[str, Any] = &lt; factory &gt;,\n    default_headers: Dict[str, str] = &lt; factory &gt;,\n    middlewares: Sequence[Union[Middleware, AsyncMiddleware]] = &lt; factory &gt;,\n    error_mappings: Dict[int, Type] = &lt; factory &gt;\n) \u2192 None\n</code></pre>"},{"location":"api/models/#classmethod-create","title":"classmethod <code>create</code>","text":"<pre><code>create(**values) \u2192 ClientConfiguration\n</code></pre> <p>Create a configuration from a dictionary. The dictionary can contain any of the attributes of the configuration. If an attribute is not present in the dictionary, the default value will be used.</p>"},{"location":"api/models/#classmethod-extract_from_func_kwargs","title":"classmethod <code>extract_from_func_kwargs</code>","text":"<pre><code>extract_from_func_kwargs(\n    self_: Optional[BaseClient],\n    cls_: Optional[BaseClient]\n) \u2192 Optional[ForwardRef('ClientConfiguration')]\n</code></pre> <p>Extract the configuration from the function bounded to class. If function is not bounded to class, return None.</p>"},{"location":"api/models/#method-merge","title":"method <code>merge</code>","text":"<pre><code>merge(other: 'ClientConfiguration') \u2192 ClientConfiguration\n</code></pre> <p>Merge two configurations. The values of the other configuration take precedence over the values of this configuration.</p>"},{"location":"api/models/#class-endpointconfiguration","title":"class <code>EndpointConfiguration</code>","text":"<p>Configuration for an endpoint. This class is used to configure the endpoint with a method, path, timeout and client configuration.</p>"},{"location":"api/models/#method-__init___2","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    client_configuration: ClientConfiguration,\n    method: str,\n    path: str,\n    timeout: Optional[float] = 5.0\n) \u2192 None\n</code></pre>"},{"location":"api/models/#property-url_template","title":"property url_template","text":"<p>The URL template for the endpoint. The URL template is the base URL of the client configuration joined with the path of the endpoint configuration.</p>"},{"location":"api/models/#class-rawrequest","title":"class <code>RawRequest</code>","text":"<p>A raw request. This class is used to configure a request with a method, URL template, path parameters, query parameters, headers, cookies, JSON body and timeout. The request can be prepared with a function and arguments. The function signature is used to modify the request before it is sent.</p>"},{"location":"api/models/#method-__init___3","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    method: str,\n    url_template: str,\n    path_params: Dict[str, str] = &lt; factory &gt;,\n    query_params: Dict[str, Any] = &lt; factory &gt;,\n    headers: Dict[str, str] = &lt; factory &gt;,\n    cookies: Dict[str, str] = &lt; factory &gt;,\n    json: Dict[str, Any] = &lt; factory &gt;,\n    timeout: Optional[float] = None\n) \u2192 None\n</code></pre>"},{"location":"api/models/#classmethod-initialize","title":"classmethod <code>initialize</code>","text":"<pre><code>initialize(endpoint_configuration: EndpointConfiguration) \u2192 RawRequest\n</code></pre> <p>Initialize a request from an endpoint configuration. The request will be initialized with the default query parameters and headers of the client configuration.</p>"},{"location":"api/models/#method-prepare","title":"method <code>prepare</code>","text":"<pre><code>prepare(func: Callable, ** values) \u2192 RawRequest\n</code></pre> <p>Prepare the request with a function and arguments. The function signature is used to modify the request before it is sent.</p>"},{"location":"api/models/#method-to_httpx_request","title":"method <code>to_httpx_request</code>","text":"<pre><code>to_httpx_request() \u2192 Request\n</code></pre> <p>Convert the request to a httpx.Request. </p>"},{"location":"core-concepts/auth/","title":"Authentication","text":""},{"location":"core-concepts/auth/#overview","title":"Overview","text":"<p>The Authentication feature allows you to simplify the process of adding authentication to your HTTP clients.</p>"},{"location":"core-concepts/auth/#authentication-types","title":"Authentication Types","text":"<p>DeclarativeX supports the following authentication types:</p> Class name Location Description <code>BasicAuth</code> Header Provide username and password, it will add base64-encoded <code>username:password</code> into <code>Authorization</code> header. <code>BearerAuth</code> Header Provide a token and it will add <code>Authorization: Bearer {token}</code> to headers. <code>HeaderAuth</code> Header Provide header name and token = <code>{header_name}: {token}</code>. <code>QueryParamsAuth</code> Query Provide a key and value, it will add it to query params: <code>{url}?{key}={value}</code>"},{"location":"core-concepts/auth/#basicauth","title":"BasicAuth","text":"<pre><code>from declarativex import BasicAuth\n\nauth = BasicAuth(username=\"my_username\", password=\"my_password\")\n</code></pre>"},{"location":"core-concepts/auth/#bearerauth","title":"BearerAuth","text":"<pre><code>from declarativex import BearerAuth\n\nauth = BearerAuth(\"my_token\")\n</code></pre>"},{"location":"core-concepts/auth/#headerauth","title":"HeaderAuth","text":"<pre><code>from declarativex import HeaderAuth\n\nauth = HeaderAuth(header_name=\"X-My-Header\", value=\"my_token\")\n</code></pre>"},{"location":"core-concepts/auth/#queryparamsauth","title":"QueryParamsAuth","text":"<pre><code>from declarativex import QueryParamsAuth\n\nauth = QueryParamsAuth(key=\"key\", value=\"my_token\")\n</code></pre>"},{"location":"core-concepts/auth/#usage","title":"Usage","text":""},{"location":"core-concepts/auth/#class-based-declaration","title":"Class-based declaration","text":"<pre><code>from declarativex import http, BaseClient, BearerAuth\n\n\nclass MyClient(BaseClient):\n    base_url = ...\n    auth = BearerAuth(\"my_token\")\n\n    @http(\"GET\", \"/users\")\n    def get_users(self) -&gt; dict:\n        ...\n</code></pre>"},{"location":"core-concepts/auth/#function-based-declaration","title":"Function-based declaration","text":"<pre><code>from declarativex import http, BearerAuth\n\n\n@http(\"GET\", \"/users\", auth=BearerAuth(\"my_token\"))\ndef get_users() -&gt; dict:\n    ...\n</code></pre> <p>Note</p> <p>If auth declared in both class and function, the function auth will be used because it has more prioritized parameters.</p>"},{"location":"core-concepts/auto-retry/","title":"Auto retry","text":""},{"location":"core-concepts/auto-retry/#what-is-auto-retry","title":"What is auto retry?","text":"<p>Auto retry is a feature that allows you to automatically retry a failed HTTP request. This is useful when you want to retry a request that failed due to a network error or a timeout.</p>"},{"location":"core-concepts/auto-retry/#how-does-it-work","title":"How does it work?","text":"<p>When you make a request, the request is sent to the server. If the server responds with an error, the request is retried. If the server responds with a success, the request is not retried.</p>"},{"location":"core-concepts/auto-retry/#how-do-i-use-it","title":"How do I use it?","text":"<p>To use auto retry, you need to decorate your endpoint method with <code>@retry</code>.</p> <p>It takes four arguments:</p> <ul> <li><code>max_retries</code>: The maximum number of times to retry the request.</li> <li><code>backoff_factor</code>: The backoff factor to use when retrying the request.</li> <li><code>exceptions</code>: The list of status codes to retry.</li> <li><code>delay</code>: The delay between retries.</li> </ul> <pre><code>from declarativex import retry, http, TimeoutException\n\n\n@retry(max_retries=3, backoff_factor=0.5, exceptions=(TimeoutException,), delay=0.5)\n@http(\"GET\", \"/status/500\", base_url=\"https://httpbin.org\", timeout=0.1)\ndef get():\n    pass\n</code></pre>"},{"location":"core-concepts/base-client/","title":"BaseClient: The Heart of DeclarativeX \u2764\ufe0f","text":""},{"location":"core-concepts/base-client/#introduction","title":"Introduction","text":"<p>Hey, welcome to the <code>BaseClient</code> section! If you're wondering what makes DeclarativeX tick, you've come to the right place. <code>BaseClient</code> is the core class that powers all the magic. Let's dive in!</p>"},{"location":"core-concepts/base-client/#initialization","title":"Initialization","text":"<p>First things first, let's see how to initialize a <code>BaseClient</code>:</p> my_client.py<pre><code>from declarativex import BaseClient\n\nclass MyClient(BaseClient):\n    ...\n</code></pre> <p>That's it! You've just created your first <code>BaseClient</code>. \ud83c\udf89</p>"},{"location":"core-concepts/base-client/#attributes","title":"Attributes","text":""},{"location":"core-concepts/base-client/#base_url","title":"<code>base_url</code>","text":"<p>The <code>base_url</code> is where all the magic starts. It's the root URL that your client will use for all requests.</p> Using class attributeUsing init argumentOverriding constructor my_client.py<pre><code>from declarativex import BaseClient\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n\n    ...\n\n\nclient = MyClient()\n</code></pre> <p>Tip</p> <p>Prefer this approach if you don't need to change the <code>base_url</code> at runtime.</p> my_client.py<pre><code>from declarativex import BaseClient\n\n\nclass MyClient(BaseClient):\n    ...\n\n\nclient = MyClient(base_url=\"https://api.example.com\")\n</code></pre> my_client.py<pre><code>from declarativex import BaseClient\n\n\nclass MyClient(BaseClient):\n    def __init__(self, *args, **kwargs):\n        kwargs[\"base_url\"] = \"https://api.example.com\"\n        super().__init__(*args, **kwargs)\n\n    ...\n\n\nclient = MyClient()\n</code></pre>"},{"location":"core-concepts/base-client/#default_headers","title":"<code>default_headers</code>","text":"<p>Need to add some custom headers? No worries, BaseClient has got you covered.</p> Using class attributeUsing init argumentOverriding constructor my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n    default_headers = {\"Authorization\": f\"Bearer {settings.EXAMPLE_API_TOKEN}\"}\n\n    ...\n\n\nclient = MyClient()\n</code></pre> <p>Tip</p> <p>Prefer this approach if you don't need to change the headers at runtime.</p> my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    ...\n\n\nclient = MyClient(\n    base_url=\"https://api.example.com\",\n    default_headers={\"Authorization\": f\"Bearer {settings.EXAMPLE_API_TOKEN}\"\n)\n</code></pre> my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    def __init__(self, *args, **kwargs):\n        kwargs[\"base_url\"] = \"https://api.example.com\"\n        kwargs[\"default_headers\"] = {\"Authorization\": \"Bearer &lt;token&gt;\"}\n        super().__init__(*args, **kwargs)\n\n    ...\n\n\nclient = MyClient()\n</code></pre>"},{"location":"core-concepts/base-client/#default_query_params","title":"<code>default_query_params</code>","text":"<p>Do you have Steam API integration ? Then you know how annoying it is to add the <code>key</code> parameter to every request. Well, <code>BaseClient</code> has got you covered.</p> Using class attributeUsing init argumentOverriding constructor my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n    default_query_params = {\"key\": settings.STEAM_API_KEY}\n\n    ...\n\n\nclient = MyClient()\n</code></pre> <p>Tip</p> <p>Prefer this approach if you don't need to change the <code>key</code> at runtime.</p> my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    ...\n\n\nclient = MyClient(\n    base_url=\"https://api.example.com\",\n    default_query_params={\"key\": settings.STEAM_API_KEY}\n)\n</code></pre> my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.settings import settings\n\n\nclass MyClient(BaseClient):\n    def __init__(self, *args, **kwargs):\n        kwargs[\"base_url\"] = \"https://api.example.com\"\n        kwargs[\"default_query_params\"] = {\"key\": settings.STEAM_API_KEY}\n        super().__init__(*args, **kwargs)\n\n    ...\n\n\nclient = MyClient()\n</code></pre>"},{"location":"core-concepts/base-client/#middlewares","title":"<code>middlewares</code>","text":"<p>Middlewares are a powerful tool that allows you to modify requests and responses.</p> Using class attributeUsing init argument my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.middlewares import MyMiddleware\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n    middlewares = [MyMiddleware()]\n\n    ...\n\n\nclient = MyClient()\n</code></pre> my_client.py<pre><code>from declarativex import BaseClient\n\nfrom myapp.middlewares import MyMiddleware\n\n\nclass MyClient(BaseClient):\n    ...\n\n\nclient = MyClient(\n    base_url=\"https://api.example.com\",\n    middlewares=[MyMiddleware()]\n)\n</code></pre> <p>Tip</p> <p>They are covered in detail in the Middlewares section.</p>"},{"location":"core-concepts/base-client/#error_mappings","title":"<code>error_mappings</code>","text":"<p>Error mappings are a powerful tool that allows you to map HTTP status codes to response parser.</p> <p>You can use <code>pydantic.BaseModel</code>, <code>dataclass</code> or <code>TypedDict</code> to parse the response.</p> Using class attributeUsing init argument my_client.py<pre><code>from declarativex import BaseClient\nfrom pydantic import BaseModel\n\nfrom myapp.middlewares import MyMiddleware\n\n\nclass BadRequestResponseSchema(BaseModel):\n    message: str\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n    error_mappings = {\n        400: BadRequestResponseSchema\n    }\n\n    ...\n\n\nclient = MyClient()\n</code></pre> my_client.py<pre><code>from declarativex import BaseClient\nfrom pydantic import BaseModel\n\nfrom myapp.middlewares import MyMiddleware\n\n\nclass BadRequestResponseSchema(BaseModel):\n    message: str\n\n\nclass MyClient(BaseClient):\n    ...\n\n\nclient = MyClient(\n    base_url=\"https://api.example.com\",\n    error_mappings={400: BadRequestResponseSchema}\n)\n</code></pre> <p>Tip</p> <p>More information you can find in the Error mappings section.</p>"},{"location":"core-concepts/base-client/#proxies","title":"<code>proxies</code>","text":"<p>Refer to this documentation to be able to use proxies: HTTP proxying</p>"},{"location":"core-concepts/base-client/#wrapping-up","title":"Wrapping Up","text":"<p>So there you have it, the <code>BaseClient</code> in all its glory. It's the cornerstone of DeclarativeX, designed to make your life easier and your code cleaner.</p> <p>Feel like diving deeper? Check out the HTTP Declaration and Dependencies sections next.</p>"},{"location":"core-concepts/dependencies/","title":"Dependencies Explained \ud83e\udd13","text":"<p>This documentation primarily consists of classes that model various types of HTTP request dependencies,  including query parameters, headers, cookies, and more. These dependencies are meant to modify and  validate the incoming request before it hits the server.</p>"},{"location":"core-concepts/dependencies/#dependency","title":"Dependency","text":"<p>You can override the default field name(that is picked from the function argument name) by passing <code>field_name</code> param.</p> <p>All the dependencies are inherited from <code>Dependency</code> class.</p>"},{"location":"core-concepts/dependencies/#path","title":"Path \ud83d\udee4\ufe0f","text":"<p>Pass data right into the URL path like so:</p> my_client.py<pre><code>from typing import Annotated\nfrom uuid import UUID\n\nfrom declarativex import http, Path\n\n\n@http(\"GET\", \"/some/path/{uuid}/\")\ndef get_some_data(\n    uuid: Annotated[UUID, Path]\n) -&gt; dict:\n    ...\n</code></pre> <p>But hey, if the arg name matches the path variable, that's your default.</p> <p>So the example above equals:</p> my_client.py<pre><code>from declarativex import http, Path\nfrom uuid import UUID\n\n\n@http(\"GET\", \"/some/path/{uuid}/\")\ndef get_some_data(\n    uuid: UUID\n) -&gt; dict:\n    ...\n</code></pre> <p>Note</p> <p>So, if you have a path variable with the same name as the function argument - <code>Path</code> will be used automatically.</p>"},{"location":"core-concepts/dependencies/#query","title":"Query \ud83d\udd0d","text":"<p>Want URL query params? No biggie:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Query\n\n\n@http(\"GET\", \"/some/path/\")\ndef get_some_data(\n    order_by: Annotated[str, Query(field_name=\"orderBy\")] = \"name_asc\"\n) -&gt; dict:\n    ...\n</code></pre> <p>Success</p> <p>Goodbye, lowerCamelCase! Hello, Pythonic style! \ud83d\udc0d</p> <p>If we had a snake_case <code>order_by</code> field in external API we deal with, the code will be like this:</p> my_client.py<pre><code>from declarativex import http\n\n\n@http(\"GET\", \"/some/path/\")\ndef get_some_data(\n    order_by: str = \"name_asc\"\n) -&gt; dict:\n    ...\n</code></pre> <p>Note</p> <p>So, if you don't have a path variable with the same name as the function argument - <code>Query</code> will be used automatically.</p>"},{"location":"core-concepts/dependencies/#jsonfield","title":"JsonField \ud83d\udce6","text":"<p>Let's imagine, that we have two data sources, and we need them to make a POST request with.</p> <p>\u2753 What are you reaching for the dictionary for, huh?</p> <p>You don't need to create a dictionary, that will contain the data, use <code>JsonField</code> dependency:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, JsonField\n\n\nclass FooClient(declarativex.BaseClient):\n    base_url=\"https://example.com/\"\n\n    @http(\"POST\", \"/bar\")\n    def create_baz(\n        foo: Annotated[str, JsonField], \n        baz: Annotated[str, JsonField],\n    ) -&gt; dict:\n        ...\n\n\nclient = FooClient()\n</code></pre> <p>Meanwhile, in the parallel ~~reality~~ file:</p> do_things.py<pre><code>def do_something():\n    foo = fetch_from_db()\n    baz = fetch_from_cache()\n    client.create_baz(foo=foo, baz=baz)\n</code></pre> <p>Example</p> <p>It will be equal to: <pre><code>any_http_lib.post(\"http://example.com/bar\", {\"foo\": foo, \"baz\": baz})\n</code></pre></p> <p>If you've actually given in and made that dictionary, check out the next parameter type... Who did I even bother for?</p>"},{"location":"core-concepts/dependencies/#json","title":"Json \ud83d\udcc4","text":"<p>Haha, so you did end up creating that damn dictionary, huh? Alright, now let's see how you're gonna use it:</p> <p>Just, to let you know, there is no <code>field_name</code> param for <code>Json</code> dependency, because it is not needed.</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Json\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    data: Annotated[dict, Json]\n) -&gt; dict:\n    ...\n</code></pre> <p>There you go, you've put it to use. Happy now? \ud83d\ude04</p>"},{"location":"core-concepts/dependencies/#formfield","title":"FormField \ud83d\udcdd","text":"<p>The same as <code>JsonField</code>, but for form data.</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, FormField\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    foo: Annotated[str, FormField], \n    baz: Annotated[str, FormField],\n) -&gt; dict:\n    ...\n</code></pre>"},{"location":"core-concepts/dependencies/#formdata","title":"FormData \ud83d\udcc4","text":"<p>The same as <code>Json</code>, but for form data.</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, FormData\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    data: Annotated[dict, FormData]\n) -&gt; dict:\n    ...\n</code></pre>"},{"location":"core-concepts/dependencies/#files","title":"Files \ud83d\udcc1","text":"<p>You can use them like this:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Files\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    files: Annotated[dict, Files]\n) -&gt; dict:\n    ...\n\n\ncreate_baz(files={\"file\": open(\"file.txt\", \"rb\")})\n# Or:\ncreate_baz(files={\"file\": (\"file.txt\", open(\"file.txt\", \"rb\"))})\n# Or:\ncreate_baz(files={\"file\": (\"file.txt\", open(\"file.txt\", \"rb\"), \"text/plain\")})\n</code></pre>"},{"location":"core-concepts/dependencies/#header","title":"Header \ud83c\udfa9","text":"<p>The difference between <code>Header</code> and any other dependency is that <code>Header</code> has only a <code>name</code> param.  And it is required.</p> <p>So, you can use them like this:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Header\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    x_foo: Annotated[str, Header(name=\"X-Foo\")]\n) -&gt; dict:\n    ...\n</code></pre> <p>Danger</p> <p>The <code>name</code> param is required for headers, because usually custom headers have <code>-</code> char.</p>"},{"location":"core-concepts/dependencies/#cookie","title":"Cookie \ud83c\udf6a","text":"<p>You can use them like this:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Cookie\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    session_id: Annotated[str, Cookie]\n) -&gt; dict:\n    ...\n</code></pre>"},{"location":"core-concepts/dependencies/#timeout","title":"Timeout \u23f1\ufe0f","text":"<p>You can define a changeable timeout using dependency:</p> my_client.py<pre><code>from typing import Annotated\n\nfrom declarativex import http, Timeout\n\n\n@http(\"POST\", \"/bar\")\ndef create_baz(\n    timeout: Annotated[int, Timeout]\n) -&gt; dict:\n    ...\n</code></pre> <p>Note</p> <p>If you need to define a constant timeout, you can use <code>timeout</code> param in <code>@http</code> decorator.</p>"},{"location":"core-concepts/error-mappings/","title":"Error mapping","text":""},{"location":"core-concepts/error-mappings/#overview","title":"Overview","text":"<p>Error mapping is a way to map errors from one type to another.  This is useful when you want to parse errors from an external API to your own schema.</p>"},{"location":"core-concepts/error-mappings/#default-behavior","title":"Default behavior","text":"<p>By default, if the server returns an error, the client will raise an <code>HTTPException</code> with the following attributes:</p> <ul> <li><code>status_code</code> - HTTP status code of the response, integer.</li> <li><code>response</code> - <code>httpx.Response</code> object.</li> <li><code>raw_request</code> - RawRequest object.</li> </ul>"},{"location":"core-concepts/error-mappings/#mapping-errors","title":"Mapping errors","text":"<p>You can map errors to your own schema by using the <code>error_mappings</code> argument of the <code>@http</code> decorator. </p> <p>You can also use <code>BaseClient</code> class to set error mappings for all endpoints.</p> <p>Note</p> <p>If you set error mappings for a specific endpoint, it will override the error mappings set in the <code>BaseClient</code> class.</p>"},{"location":"core-concepts/error-mappings/#example","title":"Example","text":"my_client.py<pre><code>from declarativex import http, Json\nfrom declarativex.exceptions import HTTPException\nfrom pydantic import BaseModel\n\n\nclass BadRequestSchema(BaseModel):\n    email: str\n\n\n@http(\n    \"POST\", \n    \"/users/\", \n    error_mappings={400: BadRequestSchema}\n)\ndef create_user(user_data: dict = Json(...)) -&gt; dict:\n    \"\"\" Endpoint is raising 400 error. \"\"\"\n    ...\n\n\ntry:\n    create_user(user_data={\"email\": \"john@example.com\"})\nexcept HTTPException as e:\n    print(e.status_code)  # 400\n    print(e.response)  # BadRequestSchema(email='User with this email already exists.')\n</code></pre> <p>Success</p> <p>Now, if the server returns a <code>400</code> error, it will be parsed to <code>BadRequestSchema</code> automatically.</p>"},{"location":"core-concepts/graphql/","title":"<code>@gql</code> decorator","text":"<p>The <code>@gql</code> decorator allows you to declare GraphQL clients, either through class-based or  function-based declarations, much like how the <code>@http</code> decorator works.  The primary difference is that you'll be defining a GraphQL query or  mutation rather than an HTTP method and path.</p>"},{"location":"core-concepts/graphql/#syntax","title":"Syntax","text":"SyncAsync <pre><code>@gql(query, *, base_url, timeout, default_headers, default_query_params, middlewares)\ndef method_name() -&gt; dict:\n    ...\n</code></pre> <pre><code>@gql(query, *, base_url, timeout, default_headers, default_query_params, middlewares)\nasync def method_name() -&gt; dict:\n    ...\n</code></pre>"},{"location":"core-concepts/graphql/#arguments-table","title":"Arguments Table","text":"<p>The arguments for <code>@gql</code> are quite similar to those for <code>@http</code>.  Instead of specifying an HTTP method and path, you specify a GraphQL query.</p> Argument Type Description <code>query</code> <code>str</code> The GraphQL query to be executed. <p>Keyword-only arguments</p> <p>All arguments after <code>query</code> are keyword-only arguments, so you must specify them by name.</p>"},{"location":"core-concepts/graphql/#priority-of-the-parameters-resolution","title":"Priority of the parameters resolution","text":"<p>The priority follows the same rules as in the <code>@http</code> decorator.</p>"},{"location":"core-concepts/http-declaration/","title":"HTTP declaration","text":"<p>DeclarativeX supports two ways of declaring clients: class-based and function-based.</p> <p>Both are equally powerful and flexible, so it's up to you to decide which one to use.</p>"},{"location":"core-concepts/http-declaration/#http-decorator","title":"<code>@http</code> decorator","text":"<p>The <code>@http</code> decorator is the core of DeclarativeX. It's used to declare endpoints and specify their parameters.</p>"},{"location":"core-concepts/http-declaration/#syntax","title":"Syntax","text":"SyncAsync <pre><code>@http(method, path, *, base_url, timeout, default_headers, default_query_params, middlewares)\ndef method_name() -&gt; dict:\n    ...\n</code></pre> <pre><code>@http(method, path, *, base_url, timeout, default_headers, default_query_params, middlewares)\nasync def method_name() -&gt; dict:\n    ...\n</code></pre> <p>Tip</p> <p>Sync and async functions are supported. Just define your function as <code>async</code> and you're good to go.</p> <p>Keyword-only arguments</p> <p>All arguments after <code>path</code> are keyword-only arguments, so you must specify them by name.</p>"},{"location":"core-concepts/http-declaration/#supported-methods","title":"Supported methods","text":"<p>DeclarativeX currently supports the following HTTP methods:</p> <ul> <li><code>GET</code></li> <li><code>POST</code></li> <li><code>PUT</code></li> <li><code>PATCH</code></li> <li><code>DELETE</code></li> </ul> <p>More HTTP methods will be added in the future.</p> <p>Case</p> <p>The HTTP method is case-insensitive, so you can use either <code>Get</code> or <code>get</code>.</p> <p>Unsupported methods</p> <p>If you will try to use unsupported HTTP method, you will get MisconfiguredException exception at the runtime.</p>"},{"location":"core-concepts/http-declaration/#declare-parameters","title":"Declare parameters","text":"<p>This table outlines the arguments you can pass to the decorator, detailing their type,  whether they're required or optional, and what each argument is for.</p>"},{"location":"core-concepts/http-declaration/#positional-arguments","title":"Positional arguments","text":"Name Type Required Arg type Description <code>method</code> <code>str</code> Yes Position Specifies the HTTP method (e.g., GET, POST, PUT) you want to use. <code>path</code> <code>str</code> Yes Position Defines the API endpoint path you're hitting."},{"location":"core-concepts/http-declaration/#keyword-only-arguments","title":"Keyword-only arguments","text":"Name Type Required Arg type Description <code>base_url</code> <code>str</code> Not always Keyword Sets the base URL for the request. <code>timeout</code> <code>int</code> No, default: <code>None</code> Keyword The timeout to use. <code>auth</code> <code>declarativex.Auth</code> No, default: <code>None</code> Keyword The auth instance to use. <code>default_headers</code> <code>dict</code> No, default: <code>None</code> Keyword The headers to use with every request. <code>default_query_params</code> <code>dict</code> No, default: <code>None</code> Keyword The params to use with every request. <code>middlewares</code> <code>list</code> No, default: <code>None</code> Keyword The middlewares to use with every request. <code>error_mappings</code> <code>dict</code> No, default: <code>None</code> Keyword The error mappings to use with every request. <code>proxies</code> <code>dict | str | None | URL | Proxy</code> No, default: <code>None</code> Keyword The proxies to use with every request. <p><code>base_url</code></p> <p>This is necessary if the method is not part of a class that already specifies it.</p> <p>If you don't specify <code>base_url</code> in function-based declaration, you will get MisconfiguredException exception at the runtime.</p>"},{"location":"core-concepts/http-declaration/#priority-of-the-parameters-resolution","title":"Priority of the parameters resolution","text":"<p>The priority of the parameters is as follows:</p> <ol> <li>Pick parameter from the decorator.</li> <li>Pick parameter from the class.</li> <li>If both are specified, merge them.</li> </ol> <p>Priority</p> <p>Decorator parameters have higher priority and will overwrite the same values of class parameter</p>"},{"location":"core-concepts/http-declaration/#return-type","title":"Return Type","text":"<p>You can use any of the custom dataclasses, Pydantic models or built-in types to parse the response automatically.</p> <p>-&gt; dict</p> <p>If you don't specify a return type, the decorator will return a <code>httpx.Response</code> object. But, your IDE will not be able to detect the type of the response, so it's recommended to specify the return type.</p> <p>explicitly specifying httpx.Response return type</p> <p>Specifying <code>httpx.Respose</code> will both return unprocessed <code>httpx.Response</code> object and  preserve type hint information for IDE.</p>"},{"location":"core-concepts/http-declaration/#class-based-declaration","title":"Class-based declaration","text":"<p>Class-based declaration is the most common way to declare clients. It's also the most flexible one.</p> <p>Use the <code>BaseClient</code> class as a base class for your client and declare methods using the <code>http</code> decorator.</p>"},{"location":"core-concepts/http-declaration/#example","title":"Example","text":"SyncAsync my_client.py<pre><code>from declarativex import BaseClient, http\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://example.com\"\n    default_query_params = {\"api_key\": \"123456\"}\n    default_headers = {\"X-Trace\": \"&lt;hash&gt;\"}\n\n    @http(\"GET\", \"/users/{user_id}\", timeout=10)\n    def get_user(self, user_id: int) -&gt; dict:\n        ...\n\n\nmy_client = MyClient()\nuser: dict = my_client.get_user(user_id=1)\n</code></pre> my_client.py<pre><code>import asyncio\n\nfrom declarativex import BaseClient, http\n\n\nclass MyClient(BaseClient):\n    base_url = \"https://example.com\"\n    default_query_params = {\"api_key\": \"123456\"}\n    default_headers = {\"X-Trace\": \"&lt;hash&gt;\"}\n\n    @http(\"GET\", \"/users/{user_id}\", timeout=10)\n    async def get_user(self, user_id: int) -&gt; dict:\n        ...\n\n\nmy_client = MyClient()\nuser: dict = asyncio.run(my_client.get_user(user_id=1))\n</code></pre> <p>Class-based declaration</p> <p>If you're using class-based declaration, you must pass <code>self</code> as the first argument to the method.</p> <p>It will be used to get the <code>base_url</code>, <code>default_query_params</code>, <code>default_headers</code> and other values.</p>"},{"location":"core-concepts/http-declaration/#function-based-declaration","title":"Function-based declaration","text":"<p>Function-based declaration is a great alternative to class-based declaration. It's more concise and doesn't require you to create a class. Commonly used for simple clients with one endpoint.</p>"},{"location":"core-concepts/http-declaration/#example_1","title":"Example","text":"SyncAsync my_client.py<pre><code>from declarativex import http\n\n\n@http(\n    \"GET\", \n    \"/users/{user_id}\", \n    base_url\"https://example.com\",\n    timeout=10,\n    default_headers={\"X-Trace\": \"&lt;hash&gt;\"},\n    default_query_params={\"api_key\": \"123456\"}\n)\ndef get_user(user_id: int) -&gt; dict:\n    ...\n</code></pre> my_client.py<pre><code>import asyncio\n\nfrom declarativex import http\n\n\n@http(\n    \"GET\", \n    \"/users/{user_id}\", \n    base_url\"https://example.com\",\n    timeout=10,\n    default_headers={\"X-Trace\": \"&lt;hash&gt;\"},\n    default_query_params={\"api_key\": \"123456\"}\n)\ndef get_user(user_id: int) -&gt; dict:\n    ...\n\nuser: dict = asyncio.run(get_user(user_id=1))\n</code></pre> <p>Function-based declaration</p> <p>If you're using function-based declaration, you don't need to add <code>self</code> as first argument. The parameters of the decorator will be used to get the <code>base_url</code>, <code>default_query_params</code> and <code>default_headers</code> values.</p>"},{"location":"core-concepts/middlewares/","title":"Middlewares","text":""},{"location":"core-concepts/middlewares/#overview","title":"Overview","text":"<p>The Middleware feature allows you to inject custom logic into the request/response cycle of an HTTP client library. Middlewares can be both synchronous and asynchronous, providing a versatile way to modify outgoing requests or handle incoming responses.</p>"},{"location":"core-concepts/middlewares/#usage","title":"Usage","text":"<p>To create your middleware, extend the Middleware class and implement the call method.</p>"},{"location":"core-concepts/middlewares/#synchronous-middleware","title":"Synchronous Middleware","text":"<p>Here's an example of a synchronous middleware that logs information before and after the call_next invocation.</p> <pre><code>import logging\n\nfrom declarativex import Middleware\n\n\nclass FooMiddleware(Middleware):\n    def __call__(self, *, request, call_next):\n        logging.info(\"pre FooMiddleware\")\n        response = call_next(request)\n        logging.info(\"post FooMiddleware\")\n        return response\n</code></pre>"},{"location":"core-concepts/middlewares/#asynchronous-middleware","title":"Asynchronous Middleware","text":"<p>For async operations, you can define the call method as asynchronous.</p> <pre><code>import logging\n\nfrom declarativex import Middleware\n\n\nclass FooMiddleware(Middleware):\n    async def __call__(self, *, request, call_next):\n        logging.info(\"pre FooMiddleware\")\n        response = await call_next(request)\n        logging.info(\"post FooMiddleware\")\n        return response\n</code></pre>"},{"location":"core-concepts/middlewares/#signature-checking","title":"Signature checking","text":"<p>The Middleware class uses a metaclass to check the signature of the call method.  This ensures that the middleware is implemented correctly and that the executor can invoke it properly.</p>"},{"location":"core-concepts/middlewares/#inheriting-from-middleware","title":"Inheriting from <code>Middleware</code>","text":"<p>To create your own middleware, you simply inherit from the Middleware class and implement the call method.  The Signature metaclass will automatically check the call method's signature at the time of class definition.</p> <p>Here's how you could inherit from the Middleware class:</p> <pre><code>class CustomMiddleware(Middleware):\n    def __call__(self, *, request: RawRequest, call_next: Callable[[RawRequest], ReturnType]) -&gt; ReturnType:\n        # Your custom logic here\n</code></pre>"},{"location":"core-concepts/middlewares/#synchronous-and-asynchronous-middleware-interactions","title":"Synchronous and Asynchronous Middleware Interactions","text":""},{"location":"core-concepts/middlewares/#sync-in-async-and-async-in-sync","title":"Sync in Async and Async in Sync","text":"<p>While both synchronous and asynchronous middlewares can be created, it's important to note that they can't be mixed within the same HTTP function. Attempting to do so will result in a runtime exception. Here's how this validation works in practice:</p>"},{"location":"core-concepts/middlewares/#sync-middleware-in-async-function","title":"Sync Middleware in Async Function","text":"<p>If you try to use a synchronous middleware within an asynchronous function, you'll encounter a <code>MisconfiguredException</code>.</p> <pre><code>import pytest\n\nfrom declarativex import http, MisconfiguredException, Middleware\n\n\nclass FooMiddleware(Middleware):\n    def __call__(self, *, request, call_next):\n        ...\n\n\nclass AsyncBarMiddleware(Middleware):\n    async def __call__(self, *, request, call_next):\n        ...\n\n\n@pytest.mark.asyncio\nasync def test_sync_async_middleware():\n    @http(\n        \"GET\", \n        \"api/users\", \n        base_url=\"https://example.com\", \n        middlewares=[FooMiddleware(), AsyncBarMiddleware()]\n    )\n    async def get_users():\n        pass\n\n    with pytest.raises(MisconfiguredException) as exc:\n        await get_users()\n\n    assert str(exc.value) == \"Cannot use sync middleware with async function\"\n</code></pre>"},{"location":"core-concepts/middlewares/#async-middleware-in-sync-function","title":"Async Middleware in Sync Function","text":"<p>Likewise, using an asynchronous middleware within a synchronous function will also trigger a <code>MisconfiguredException</code>.</p> <pre><code>import pytest\n\nfrom declarativex import http, MisconfiguredException, Middleware\n\n\nclass FooMiddleware(Middleware):\n    def __call__(self, *, request, call_next):\n        ...\n\n\nclass AsyncBarMiddleware(Middleware):\n    async def __call__(self, *, request, call_next):\n        ...\n\n\ndef test_sync_async_middleware():\n    @http(\n        \"GET\", \n        \"api/users\", \n        base_url=\"https://example.com\", \n        middlewares=[FooMiddleware(), AsyncBarMiddleware()]\n    )\n    def get_users():\n        pass\n\n    with pytest.raises(MisconfiguredException) as exc:\n        get_users()\n\n    assert str(exc.value) == (\n        \"Cannot use sync middleware(FooMiddleware) with async function\"\n    )\n</code></pre>"},{"location":"core-concepts/middlewares/#how-the-validation-works","title":"How the Validation Works","text":"<p>The middleware validation occurs at the runtime. It checks the async attribute, which is set by the Signature meta-class. The _async attribute specifies whether the __call_ method in the middleware is asynchronous or not. The executor then uses this attribute to determine if a middleware is valid for a given function type.</p> <p>This ensures that the middleware type matches the function type (async-to-async or sync-to-sync), maintaining the integrity and expected behavior of the HTTP client library.</p> <p>By strictly prohibiting the mixing of sync and async, the library ensures that developers avoid unexpected behavior or tricky debugging scenarios. This makes for a more robust and predictable development experience.</p>"},{"location":"core-concepts/middlewares/#examples","title":"Examples","text":""},{"location":"core-concepts/middlewares/#simple-in-memory-cache-for-get-requests","title":"Simple in-memory cache for GET requests","text":"<p>Here's an example of a simple in-memory cache for GET requests. It uses a dictionary to store the responses and returns the cached response if the request URL is already in the cache.</p> <pre><code>from declarativex import Middleware\n\n\nclass CacheMiddleware(Middleware):\n    cache = {}\n\n    def __call__(self, *, request, call_next):\n        if request.method != \"GET\":\n            return call_next(request)\n        url = request.url()\n        if url in self.cache:\n            return self.cache.get(url)\n        response = call_next(request)\n        self.cache[url] = response\n        return response\n</code></pre>"},{"location":"core-concepts/rate-limiter/","title":"Rate limiter","text":"<p>There is a way to not get banned by the external API you're using. It's called rate limiting.</p>"},{"location":"core-concepts/rate-limiter/#algorithm","title":"Algorithm","text":"<p>So, the Token Bucket algorithm is pretty rad. It works like this:</p> <ol> <li>You start with a bucket that can hold a set number of tokens. </li> <li>Tokens are added at a fixed rate up to the bucket's max capacity. </li> <li>When a request comes in, it takes a token from the bucket to proceed. </li> <li>If the bucket's empty, the request has to wait. </li> </ol> <p>Simple, right?</p>"},{"location":"core-concepts/rate-limiter/#comparison-with-other-algorithms","title":"Comparison with other algorithms","text":""},{"location":"core-concepts/rate-limiter/#fixed-window-algorithm","title":"Fixed Window Algorithm","text":"<p>The fixed window algorithm is the simplest rate limiting algorithm. It works like this:</p> <ol> <li>You start with a counter set to 0.</li> <li>When a request comes in, you increment the counter.</li> <li>After a fixed amount of time, the counter is reset to 0.</li> <li>If the counter is greater than the max number of requests, the request is rejected.</li> <li>Otherwise, the request is allowed.</li> <li>Repeat.</li> </ol> <p>Simple to implement.</p> <p>Not very accurate, can cause rate spikes at the window boundaries.</p>"},{"location":"core-concepts/rate-limiter/#sliding-window-algorithm","title":"Sliding Window Algorithm","text":"<p>The sliding window algorithm is a bit more complex. It works like this:</p> <ol> <li>You start with a counter set to 0.</li> <li>When a request comes in, you increment the counter.</li> <li>After a fixed amount of time, you decrement the counter.</li> <li>If the counter is greater than the max number of requests, the request is rejected.</li> <li>Otherwise, the request is allowed.</li> <li>Repeat.</li> </ol> <p>It is like mix of the fixed window and token bucket algorithms.</p> <p>Smoothens out the spikes in the fixed window algorithm.</p> <p>More complex and can be resource-intensive.</p>"},{"location":"core-concepts/rate-limiter/#leaky-bucket-algorithm","title":"Leaky Bucket Algorithm","text":"<p>The opposite of the token bucket algorithm is the leaky bucket algorithm. It works like this:</p> <p>All incoming requests go into a bucket and leak out at a constant rate.</p> <ol> <li>You start with a bucket that can hold a set number of tokens.</li> <li>Tokens are added at a fixed rate up to the bucket's max capacity.</li> <li>When a request comes in, it takes a token from the bucket to proceed.</li> <li>If the bucket's empty, the request has to wait.</li> <li>If the bucket's full, the request is rejected.</li> <li>Repeat.</li> </ol> <p>Easy to predict request timing.</p> <p>Can drop requests if the bucket is full, causing some loss of service.</p>"},{"location":"core-concepts/rate-limiter/#why-token-bucket","title":"Why Token Bucket?","text":"<p>The token bucket algorithm is a good choice for rate limiting because it's simple to implement and easy to understand.</p> <p>It also has a nice property that the rate of requests is constant over time, which makes it easy to predict when requests will be allowed.</p>"},{"location":"core-concepts/rate-limiter/#rate_limiter-decorator","title":"<code>@rate_limiter</code> decorator","text":"<p>The <code>@rate_limiter</code> decorator is used to limit the number of requests to the endpoint.</p> <p>Use it to prevent your client from being banned by the server.</p> <p>It supports both sync and async declarations.</p>"},{"location":"core-concepts/rate-limiter/#syntax","title":"Syntax","text":"Per endpointPer client <pre><code>from declarativex import http, rate_limiter\n\n@rate_limiter(max_calls: int, interval: float, reject: bool)\n@http(...)\ndef method_name() -&gt; dict:\n    ...\n</code></pre> <p>Info</p> <p>It will be applied to the decorated endpoint. The bucket will be bounded to it. Only this function will consume bucket tokens.</p> <pre><code>from declarativex import http, rate_limiter, BaseClient\n\n\n@rate_limiter(max_calls, interval)\nclass MyClient(BaseClient):\n    base_url = \"https://api.example.com\"\n\n    @http(\"GET\", \"/users\")\n    def get_users(self) -&gt; dict:\n        ...\n\n    @http(\"GET\", \"/users/{user_id}\")\n    def get_user(self, user_id: int) -&gt; dict:\n        ...\n</code></pre> <p>Info</p> <p>It will be applied to all endpoints of the client. The bucket will be shared. Every endpoint will consume tokens from the same bucket.</p>"},{"location":"core-concepts/rate-limiter/#parameters","title":"Parameters","text":"<ul> <li><code>max_calls</code> - maximum number of calls to the endpoint</li> <li><code>interval</code> - interval between calls in seconds</li> <li><code>reject</code> - whether to reject the request or wait for the next interval. Defaults to <code>False</code>, if <code>True</code> - raises <code>RateLimitExceeded</code> exception.</li> </ul>"}]}